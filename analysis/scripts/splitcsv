#!/usr/bin/env python2
#
# splitcsv
#   Split csv generated by the fitting application into a parts, one for each video
#
# by Anton Schubert <anton.schubert@mailbox.org>

import argparse
import csv
from collections import namedtuple
from os import path
from eyetrackerlib import *

parser = argparse.ArgumentParser(description="Split fitting csv into a seperate file for each video")
parser.add_argument("-c", dest="csv", required=True, help="csv file (fitting output)")
parser.add_argument("-o", dest="out", default=".", help="output directory")
args = parser.parse_args()

Video = namedtuple("Video", ["start", "end", "title"])
VideoRow = namedtuple("VideoRow", ["frame", "x", "y", "cX", "cY"])

def writeCSV(userid, videoname, videoData):
    outdir = path.join(args.out, path.splitext(videoname)[0])
    mkdir_p(outdir)
    csvfile = open(path.join(outdir, userid + ".csv"), "wb")
    writer = csv.writer(csvfile, delimiter=",")
    writer.writerow(["frame", "x", "y", "CI_x", "CI_y"])
    for row in videoData:
        writer.writerow([row.frame, row.x, row.y, row.cY, row.cX])
    csvfile.close()

def nextCalibrationIndex(index):
    for i in range(index + 1, len(data)):
        row = data[i]
        if (row.CI_x != "" and row.CI_y != ""):
            return i

# Cut relevant part out of csv data
def extract(start, end, data):
    # initialize running variables
    currCalIdx = nextCalibrationIndex(0)
    nextCalIdx = currCalIdx
    currCal = data[currCalIdx]
    nextCal = data[nextCalIdx]

    videoData = []
    for i in range(len(data)):
        row = data[i]

        # new calibration error
        if i == nextCalIdx:
            currCalIdx, currCal = i, data[i]
            index = nextCalibrationIndex(i)

            # if there are no further index frames, leave the calibration as it is
            if index is not None:
                nextCalIdx = index
                nextCal = data[index]

        # just interpolate errors in the range of the video
        if int(row.frame) < start:
            continue
        elif int(row.frame) > end:
            break

        # linear interpolation of prediction error
        if nextCalIdx == currCalIdx:
            cX = abs(float(currCal.CI_x))
            cY = abs(float(currCal.CI_y))

        else:
            cX = ((nextCalIdx - i) * abs(float(currCal.CI_x)) +
                  (i - currCalIdx) * abs(float(nextCal.CI_x))) / (nextCalIdx - currCalIdx)
            cY = ((nextCalIdx - i) * abs(float(currCal.CI_y)) +
                  (i - currCalIdx) * abs(float(nextCal.CI_y))) / (nextCalIdx - currCalIdx)

        videoData.append(VideoRow(frame = int(row.frame) - start, x = float(row.x), y = float(row.y), cX = cX, cY = cY))
    return videoData

# load fixation data from csv
data = parseCSV(args.csv)
userid = path.splitext(path.basename(args.csv))[0]

# Parse video metadata from csv
videos = []
title = None
start = None
for i in range(len(data)):
    item = data[i]
    if item.notes.startswith("videoStart"):
        title = item.notes.split(":")[1]
        start = i

    elif (item.notes.startswith("videoEnd") and
             title is not None and start is not None):
        videoData = extract(start, i, data)
        writeCSV(userid, title, videoData)

